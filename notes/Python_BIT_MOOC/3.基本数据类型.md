## 3.基本数据类型

### 3.1 数字类型及操作

#### 整数类型

- 整数类型：与数学中整数概念一致
  - 可正可负，没取值限制
  - pow(x,y)，计算$x^y$
  - 四种进制表示形式
    - 十进制
    - 二进制，以0b/0B开头：0b010，-0B101
    - 八进制，以0o/0O开头
    - 十六进制，以0x/0X开头

#### 浮点数类型

- 浮点类型：与数学实数概念一致

  - 带有小数点及小数的数字

  - 浮点数取值范围和小数精度都存在限制，常规计算下可忽略

  - 取值范围约为$-10^{308}$到$10^{308}$，精度数量级$10^{-16}$

  - **浮点数运算存在不确定尾数**，不是bug

    - \>\>\>0.1+0.3

      0.4

      \>\>\>0.1+0.2

      0.30000000000000004

    - 这涉及到计算机的内部原理

      计算机中所有数字都是用二进制表示

      Python中用53位二进制表示小数部分

      0.1的二进制是0.00011001100110011001100110011...

      而计算机只能截取53位，无限接近0.1

      因此二进制表示小数可无限接近，但不相同

      所以0.1+0.2结果接近0.3而存在尾数

    - \>\>\>0.1+0.2==0.3

      False

      \>\>\>round(0.1+0.2,1)==0.3

      True

      round(x,d)：对x**四舍五入**，d是小数截取位数#可用int(x)取整

    - 浮点数运算及比较用round()函数辅助

    - 不确定尾数一般发生在$10^{-16}$左右，round()十分有效

  - 浮点数可用科学计数法表示

    - 使用e/E为幂的符号，以10为基数
    - \<a>e\<b>表示$a*10^b$
    - 用这种方式表达比较大或非常小的浮点数

#### 复数类型

- 复数类型：与数学中复数概念一致

  - $j=\sqrt{(-1)}$，a+b**j**被称为复数，a是实部，b是虚部

  - 实例：z=1.23e-4+5.6e+89j

    z.real获得实部

    z.imag获得虚部

  - 应用：复变函数

#### 数值运算操作符

- 操作符是完成运算的一种符号体系

  - x+y,x-y,x*y
  - x/y，在其他一些语言中整数用/是整数除，而Python中仅是数学意义上的除
  - x//y，整数除，10//3=3
  - +x，x本身
  - -y，y的负值
  - x%y，求余/模运算，10%3=1
  - x**y
    - 幂运算，x的y次幂
    - y为小数时开方运算，4**0.5=2

- 二元操作符有对应的增强赋值操作符：x op=y

  - x+=y，x=x+y
  - x-=y，x=x-y
  - x\*=y，x=x\*y
  - x/=y，x=x/y
  - x//=y，x=x//y
  - x%=y，x=x%y
  - x\*\*=y，x=x\*\*y

- 类型间可以进行混合运算，生成结果为“最宽”类型

  ​	整数->浮点数->复数

  ​	如：123+4.0=127.0

#### 数值运算函数

- 一些以函数形式提供的数值运算功能

  - abs(x)，求x绝对值

  - divmod(x,y)，商余，同时输出商和余数，divmod(10,3)结果是(3,1)（二元素）

  - pow(x,y[,z])，幂余，(x**y)%z，[...]表示z可省略

  - pow(3,pow(3,99),10000)得到了3的（3的99次方）次方的后四位

    直接算pow(3,pow(3,99))无法在普通计算机中得到结果，会超出内存

    通过余数z是运算始终保持在余数范围内

  - round(x[,d])，四舍五入，d是保留小数位数，默认为0（取整）

  - max(x1,x2,...,xn)返回其中最大值，n不限

  - min(x1,x2,...,xn)返回其中最小值，n不限

  - 数值类型转换函数

    - int(x)，将x变成整数，舍弃小数部分

      int(123.45)=123;int("123")=123

    - float(x)，将x变为浮点数，增加小数部分

      float(12)=12.0;float("1.23")=1.23

    - complex(x)，将x变为复数，增加虚数部分

      complex(4)=4+0j

### 3.2 实例3：天天向上的力量

#### “天天向上的力量”问题分析

- 基本问题：持续的价值

  - 一年365天，每天进步1%，累计进步多少呢

    $1.01^{365}$

  - 一年365天，每天进步1%，累计剩下多少呢

    $0.99^{365}$

  - 可以用数学公式求解，但用程序快

  - 如果是“三天打鱼两天晒网”呢

  - 如果是“双休日不退步”呢

#### “天天向上的力量”第一问

- 问题1：千分之一的力量

  - 一年365天，每天进步1%。，累计进步多少呢

    $1.001^{365}$

  - 一年365天，每天退步1%。，累计退步多少呢

    $0.999^{365}$

```python
#DayDayUpQ1.py
dayup=pow(1.001,365)
daydown=pow(0.999,365)
print("向上:{:.2f},向下:{:.2f}".format(dayup,daydown))
```

向上:1.44,向下:0.69

#### “天天向上的力量”第二问

- 问题2：千分之五和百分之一的力量
  - 一年365天，每天进步5%。或1%，累计进步多少呢
  - 一年365天，每天退步5%。或1%。，累计退步多少呢

```python
#DayDayUpQ2.py
dayfactor=0.005#引入变量的好处：只需一处修改即可
dayup=pow(1+dayfactor,365)
daydown=pow(1-dayfactor,365)
print("向上:{:.2f},向下:{:.2f}".format(dayup,daydown))
```

0.005时	向上:6.17,向下:0.16

0.01时	向上:37.78,向下:0.03

#### “天天向上的力量”第三问

- 问题3：工作日的力量

  - 一年365天，一周5个工作日，每天进步1%

  - 一年365天，一周2个休息日，每天退步1%

    $1.01^{365}$（数学思维）=>for...in...（计算思维）

```python
#DayDayUpQ3.py
dayup=1.0
dayfactor=0.01
for i in range(365):
    if i%7 in [6,0]:
        dayup=dayup*(1-dayfactor)
    else:
        dayup=dayup*(1+dayfactor)
print("工作日的力量:{:.2f}".format(dayup))
```

工作日的力量:4.63

介于千分之五和千分之一之间

#### “天天向上的力量”第四问

- 问题4：工作日的努力

  - 工作日模式要努力到什么水平，才能与每天努力1%一样

  - A：一年365，每天进步1%

  - B：一年365，每周工作5，休息2，休息日下降1%，要多努力

    for...in...（计算思维）=>def...while...（“笨方法”试错）

```python
#DayDayUpQ4.py
def dayUP(df):
    dayup=1
    for i in range(365):
        if i%7 in [6,0]:
            dayup=dayup*(1-0.01)
        else:
            dayup=dayup*(1+df)
    return dayup
#def保留字用于定义函数
#根据df参数计算工作日力量的函数
#参数不同，这段代码可以共用
dayfactor=0.01
while dayUP(dayfactor)<37.78:
    dayfactor+=0.001
print("工作日的努力参数是:{:.3f}".format(dayfactor))
#while保留字判断条件是否成立
#条件成立时循环进行
```

工作日的努力参数是:0.019

> GRIT:perseverance and passion for long-term goals
>
> $1.01^{365}=37.78$	$1.019^{365}=962.89$
>
> GRIT，坚毅，对长期目标的持续激情及持久耐力
>
> GRIT是获得成功最重要的因素之一，牢记天天向上的力量

#### “天天向上的力量”举一反三

在Q3中

```python
#DayDayUpQ3.py
dayup=1.0
dayfactor=0.01
for i in range(365):
    if i%7 in [6,0]:
        dayup=dayup*(1-dayfactor)
    else:
        dayup=dayup*(1+dayfactor)
print("工作日的力量:{:.2f}".format(dayup))
```

我们抛弃了数学思维，引入了计算思维for...in...，这种计算思维是*抽象和自动化*相结合的结果，计算机的算力使得*抽象和自动化*带来了问题的快速求解

在Q4中

```python
#DayDayUpQ4.py
def dayUP(df):
    dayup=1
    for i in range(365):
        if i%7 in [6,0]:
            dayup=dayup*(1-0.01)
        else:
            dayup=dayup*(1+df)
    return dayup
#def保留字用于定义函数
#根据df参数计算工作日力量的函数
#参数不同，这段代码可以共用
dayfactor=0.01
while dayUP(dayfactor)<37.78:
    dayfactor+=0.001
print("工作日的努力参数是:{:.3f}".format(dayfactor))
#while保留字判断条件是否成立
#条件成立时循环进行
```

我们使用了def...while...试错，这也是计算机算力通过程序的体现

“天天向上的力量”中包含了：判断条件循环，次数循环，分支，函数，计算思维

- 问题的变化和拓展
  - 工作日模式中，休息日不下降？
  - 每天提高百分之一，休息下降千分之一？
  - 工作3天休息一天？
  - “三天打鱼两天晒网”？
  - 努力>下降？下降>努力？

### 3.3 字符串类型及操作

#### 字符串类型的表示

- 字符串：由0个或多个字符组成的有序字符序列

  - 字符串由一对单引号/双引号表示

  - 是字符的有序序列，可以对其中的字符进行索引（从0编号）

  - 有2类4种表示方法

    - 由一对单引号/双引号表示，仅表示单行字符串

    - 一对三单引号/三双引号表示，可表示多行字符串（也可以起到多行注释的作用）

    - 如果希望在字符串种包含双引号**或**单引号？

      如果在字符串中希望出现双引号则两侧可用单引号

      如果在字符串中希望出现单引号则两侧可用双引号

    - 如果希望在字符串种包含双引号**和**单引号？

      可以用三个单引号表示

- 字符串的序号

  - 正向递增序号和反向递减序号

    正向递增序号：0，1，2，...

    反向递减序号：-1，-2，-3，...

- 字符串的使用：使用[]获取字符串中一个或多个字符串

  - 索引：返回字符串中单个字符	<字符串>[M]
  - 切片：返回字符串中一段字符子串     <字符串>[M:N]

- 字符串切片高级用法：使用[M:N:K]根据步长对字符串切片

  - <字符串>[M:N]，M缺失表示至开头，N缺失表示至结尾

  - <字符串>[M:N:K]，根据步长K对字符串切片

    "〇一二三四五六七八九十"[1:8:2]结果是"一三五七"

    特别的，"〇一二三四五六七八九十"**[::-1]**结果是"十九八七六五四三二一〇"（从后向前逐一取出）

- 字符串的特殊字符

  - 转义符\

    - 转义符表达特定字符的本意：即\后的字符将被当作字符本意理解

      如："这里有个双引号(\")"结果为	这里有个双引号(")

    - 转义符形成一些组合，表达一些不可打印的含义

      \b回退（使光标回退）	\n换行（使光标移动到下行行首）	\r回车（使光标移动到本行首）

#### 字符串操作符

- 字符串操作符
  - x+y连接两字符串x，y
  - n\*x或x\*n复制n次字符串x
  - x in s，如果x是s的子串，返回True，否则返回False
  - 例子：获取星期字符串
    - 输入：1-7的整数，表示星期几
    - 输出：输入整数对应星期字符串
    - 如：输入3，输出星期三

```python
#WeekNamePrintV1.py
weekStr="星期一星期二星期三星期四星期五星期六星期日"
weekId=eval(input("请输入星期数字（1-7）："))
pos=(weekId-1)*3
print(weekStr[pos:pos+3])
#也可用ifelse逐一判断，但毫无疑问这种方式简单简洁
```

```python
#WeekNamePrintV2.py
weekStr="一二三四五六日"
weekId=eval(input("请输入星期数字（1-7）："))
print("星期"+weekStr[weekId-1])
```

#### 字符串处理函数

- 字符串处理函数：一些以函数形式提供的字符串处理功能

  - len(x)，返回字符串x的长度

  - str(x)，将任何类型的x转换为字符串形式（与eval()函数是一对对应的函数）

  - hex(x)/oct(x)，将整数x转换为其十六进制/八进制小写形式的字符串

    计算机内部运算用二进制完成=>二进制大量01对人类读取不友好=>人们喜欢十六/八进制来表示计算机内部运算形式

    通过这两个函数可以将计算机的一些运算操作通过字符串的形式打印出来，尤其是程序员关心的系统级程序的使用

  - chr(u)，u为Unicode编码，返回其对应字符

  - ord(x)，x为字符，返回其对应的Unicode编码

- Unicode编码：也是Python字符串的编码方式

  - 统一字符编码，希望覆盖实际上所有字符

  - 从0到1114111(0x10FFFF)空间，每个编码对应一个字符

  - Python字符串中每个字符都是Unicode编码字符

    使得Python通用处理不同国家语言

  - 有趣的例子

    - \>\>\>"1+1=2"+chr(10004)

      '1+1=2✔'

    - \>\>\>"这个字符♉的Unicode值是："+str(ord("♉"))

      '这个字符♉的Unicode值是：9801'

      （可以输出chr(9800)~chr(9811)，即十二个星座玩一下）

#### 字符串处理方法

- 字符串处理方法

  - “方法”在编程中是一个专有名词

    - “方法”特指\<a>.\<b>()风格中的函数\<b>()

    - “方法”本身也是函数但与\<a>有关，\<a>.\<b>()风格使用

    - 字符串及变量也是\<a>，存在一些“方法”

    - 本课程仅讲解基本语法体系，而不讲解面向对象编程

      事实上，\<a>.\<b>()风格恰恰是面向对象的使用风格，其中\<a>是对象，\<b>是某对象能提供的功能，叫方法

      “方法”是面向对象编程里的专有名词，这里是借用

      注意，方法必须要用“.”的形式执行

  - 一些以方法形式提供的字符串处理功能

    - str.lower()或str.upper()，返回字符串副本，使得字符串中的字符全小写/大写

    - str.split(sep=None)，返回一个列表，由str根据sep被分隔部分组成；如："A,B,C".split(",")结果为['A','B','C']

      **默认根据空格分隔**

    - str.count(sub)，返回子串sub在str中出现的次数

    - str.replace(old,new)，返回字符串str的副本，所有old子串被替换为new

      **注意使用时str=str.replace(old,new)**

    - str.center(width[,fillchar])，字符串str在宽度width中居中，fillchar可选，用于填充空白；如："python".center(20,"=")结果为'\=\=\=\=\=\=\=python\=\=\=\=\=\=\='

    - str.strip(chars)，从str中去掉在其左侧和右侧chars中**列出**的字符；如："= python= ".strip(" =np")结果为'ytho'

    - str.join(iter)，在iter变量除最后一个元素外每个元素后增加一个str；如：",".join("12345")结果为"1,2,3,4,5"#主要用于字符串分隔等

#### 字符串类型的格式化

- 字符串类型的格式化：格式化是对字符串进行格式表达的方式

  - 字符串格式化使用.format()方法，用法如下：

    <模板字符串>.format(<逗号分隔的参数>)

  - 槽：一对占位信息符，用"{}"表示，只在字符串中有用

    如："{}:计算机{}的CPU占用率为{}%".format("2018-10-10","C",10)

    其中默认状态下槽与format中参数一一对应，**从0开始编号**

    当然也可以将参数按需要的顺序填入槽中

    如："{1}:计算机{0}的CPU占用率为{2}%".format("2018-10-10","C",10)

- format()方法的格式控制

  - 槽内部对格式化的配置方式

    {<参数序号>:<格式控制标记>}

  - <填充>、<对齐>、<宽度>

    - 填充：用于填充的单个字符

    - 对齐：<左对齐、>右对齐、^居中对齐

    - 宽度：槽设定的输出宽度

    - \>\>\>"{0:=^20}".format("PYTHON")

      '\=\=\=\=\=\=\=PYTHON\=\=\=\=\=\=\='

    - \>\>\>"{0:*>20}".format("BIT")

      '\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*BIT'

    - \>\>\>"{:10}".format("BIT")

      'BIT       '

  - <,>、<.精度>、<类型>

    - ，：数字的千位分隔符（输出的数字字符串便于阅读）

    - .精度：浮点数小数精度或字符串最大输出长度

    - 类型：整数类型b,c,d,o,x,X浮点数类型e,E,f,%

    - \>\>\>"{0:,.2f}".format(12345.6789)

      '12,345.68'

    - \>\>\>"{0:b},{0:c},{0:d},{0:o},{0:x},{0:X}".format(425)

      '110101001,Ʃ,425,651,1a9,1A9'

      - b：二进制形式
      - c：Unicode编码形式
      - d：十进制形式
      - o：八进制形式
      - x：十六进制形式
      - X：大写的十六进制形式

    - \>\>\>"{0:e},{0:E},{0:f},{0:%}".format(3.14)

      '3.140000e+00,3.140000E+00,3.140000,314.000000%'

      - e：科学计数法e形式
      - E：科学计数法E形式
      - f：通常的，非科学计数法形式
      - %：百分数形式

### 3.4 模块2：time库的使用

#### time库基本介绍

- time库是Python中处理时间的标准库

  - 计算机时间的表达

  - 提供获取系统时间并格式化输出的功能

  - 提供系统级精确计时功能，用于程序性能分析

  - 使用：

    import time

    time.\<b>()

- time库包括三类函数

  - 时间获取：time(),ctime(),gmtime()
  - 时间格式化：strftime(),strptime()
  - 程序计时：sleep(),perf_counter()

#### 时间获取

- time()：获取当前时间戳，即计算机内部时间值，浮点数，表示从1970.1.1，0：00开始到当前，以秒为单位的数值

  \>\>\>time.time()

  1596614684.456416

- ctime()：获取当前时间并以易读方式表示，返回字符串

  \>\>\>time.ctime()

  'Wed Aug  5 16:06:32 2020'

- gmtime()：获取当前时间，表示为计算机可处理的时间格式

  \>\>\>time.gmtime()

  time.struct_time(tm_year=2020, tm_mon=8, tm_mday=5, tm_hour=8, tm_min=8, tm_sec=4, tm_wday=2, tm_yday=218, tm_isdst=0)

#### 时间格式化

- 将时间以合理方式展示出来

  - 格式化：类似字符串格式化，需要展示模板

  - 展示模板由特定格式化控制符组成

  - strftime()方法

    - strftime(tpl,ts)

    - tpl是格式化模板字符串，用来定义输出效果

    - ts是计算机内部时间类型变量

    - \>\>\>time.strftime("%Y-%m-%d %H:%M:%S",time.gmtime())

      '2020-08-05 08:13:11'

    - tpl中

      - %Y：年份，数字
      - %m：月份，数字
      - %B：月份英文名
      - %b：月份英文名缩写
      - %d：日期，数字
      - %A：英文的星期
      - %a：英文星期缩写
      - %H：小时（24h），数字
      - %I(大写i)：小时（12h），数字
      - %p：AM/PM
      - %M：分钟，数字
      - %S：秒，数字

  - strptime()方法

    - 与strftime()操作相反，相当于反格式化

    - \>\>\>time.strptime('2020-08-05 08:13:11',"%Y-%m-%d %H:%M:%S")

      time.struct_time(tm_year=2020, tm_mon=8, tm_mday=5, tm_hour=8, tm_min=13, tm_sec=11, tm_wday=2, tm_yday=218, tm_isdst=-1)

#### 程序计时应用

- 程序计时

  - 程序计时应用广泛

    - 程序计时指测量起止动作所经历时间的过程
    - 即一段程序开始到结束用时
    - 测量时间：perf_counter()
    - 产生时间：sleep()

  - perf_counter()

    - 返回CPU级别（纳秒）精确的时间计数值，单位为秒

    - 由于计数值起点不确定，连续调用取差值才有意义

  - sleep(s)

    - s为让程序休眠的时间，单位是秒，可以是浮点数

### 3.5 实例4：文本进度条

#### “文本进度条”实例分析

- 需求分析
  - 文本进度条
    - 采用字符串方式打印可以动态变化的文本进度条
    - 需要能在一行中逐渐变化
- 问题分析
  - 如何获得文本进度条的变化时间？
    - 采用sleep()模拟一个持续的进度
    - 用字符串模拟，不难

#### “文本进度条”简单的开始

```python
#TextProBarV1.py
import time
scale=10
print("------执行开始------")
for i in range(scale+1):
    a='*'*i
    b='.'*(scale-i)
    c=(i/scale)*100
    print("{:^3.0f}%[{}->{}]".format(c,a,b))
    time.sleep(0.1)
print("------执行结束------")
```

#### ”文本进度条“单行动态刷新

- 单行动态刷新
  - 刷新的本质是：用后打印的字符覆盖之前的字符
  - 不能换行：print()需要被控制
  - 要能回退：打印后光标退回到之前的位置（当前行的行首）\r

```python
#TextProBarV2.py
import time
for i in range(101):
    print("\r{:3}%".format(i),end="")
    time.sleep(0.1)
```

可是这段程序在IDLE里的输出却并**不能看到单行刷新的效果**

因为IDLE本身是一个编写程序的开发环境，不是程序运行的主要环境，正常运行程序通过双击/控制台，**IDLE为保证其中参数的运行效果，就把\r功能屏蔽了**

windows下看到运行效果的方法：

1. 按住shift同时右键py文件所在文件夹
2. 选择在此处打开powershell窗口
3. 在窗口中输入python TextProBarV2.py（即用这样的命令执行程序）

#### ”文本进度条“实例完整效果

```python
#TextProBarV3.py
import time
scale=50
print("执行开始".center(scale//2,"-"))
start=time.perf_counter()
for i in range(scale+1):
    a='*'*i
    b='.'*(scale-i)
    c=(i/scale)*100
    dur=time.perf_counter()-start
    print("\r{:^3.0f}%[{}->{}]{:.2f}s".format(c,a,b,dur),end='')
    time.sleep(0.1)
print("\n"+"执行结束".center(scale//2,'-'))
```

#### ”文本进度条“举一反三

- 计算问题拓展

  - 文本进度条程序使用了perf_counter()计时
  - 计时方法适合各类需要统计时间的计算问题
  - 例如：比较不同算法时间、统计部分程序运行时间

- 进度条拓展

  - 在任何运行时间需要较长的程序中增加进度条

  - 在任何希望提高用户体验的应用中增加进度条

  - 进度条是人机交互的纽带之一

  - 我们有很多种让计算机展示进度的方式

    - 如在计算机下载了90%时展示为10%或下载了10%时展示为90%

    - 科学家在某次实验中用了9种算法并观察用户体验

      为Linear,Early Pause,Late Pause,Slow Wavy,Fast Wavy,Power,Inverse Power,Fast Power,Inverse Fast Power，有兴趣可查

      结论是：速度上显得先慢后快的更符合人类心理需求

### 练习

1. # 实例3：天天向上的力量

   ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **描述**

   **这是"实例"题，与课上讲解实例相同，请作答检验学习效果。**‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   工作日模式要努力到什么水平，才能与每天努力1%一样？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   -A君: 一年365天，每天进步1%，不停歇 ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   -B君: 一年365天，每周工作5天休息2天，休息日下降1% ，要多努力呢？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   每周工作5天休息2天，计算工作日的努力参数是多少才能与每天努力1%一样。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   要求如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   (1) ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬一年365天，以第0天的能力值为基数，记为1.0；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   (2) ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬当好好学习时，能力值相比前一天提高1%；当没有学习时，由于遗忘等原因能力值相比前一天下降1%； ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬ ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ------

   ## **输出**

   输出结果格式如下：（其中结果保留小数点后三位，冒号后有一个空格）‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   工作日的努力参数是: 0.019

   ```python
   a=1
   for i in range(365):
      a=a*1.01
      
   def gao(improve):
       b=1
       for i in range(365):
           if i%7 in [0,6]:
               b=b*0.99
           else:
               b=b*(1+improve)
       return b<a
   
   b=0.01
   while(gao(b)):
       b+=0.001
   print("工作日的努力参数是: {:.3f}".format(b))
   ```

2. # **实例4：文本进度条**

   ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **描述**

   **这是"实例"题，与课上讲解实例相同，请作答检验学习效果。**‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   采用字符串方式打印可以动态变化的文本进度条‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬，进度条需要能在一行中逐渐变化‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ![img](https://leaf-salix.github.io/notes/Python%E5%AD%A6%E4%B9%A0_pictures/9.png)‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   要求如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   (1) 采用sleep()模拟一个持续的进度,获得文本进度条的变化时间；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   (2) 通过print()函数实现单行动态刷新，在print()函数中更换参数end的默认值为'',每次使用print()函数输出时不能换行；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   (3) 要能回退：打印后光标到之前的位置 \r。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   请在Windows的命令行（cmd或PowerShell）或其他操作系统的命令行下执行Python程序，获得进度条效果。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ------

   ## **输出**

   ![img](https://leaf-salix.github.io/notes/Python%E5%AD%A6%E4%B9%A0_pictures/10.png)

   ```python
   import time
   a=50
   print("执行开始".center(a//2,'-'))
   g=time.perf_counter()
   for i in range(a+1):
       b=i*'*'
       c=(a-i)*'.'
       d=(i/a)*100
       e=time.perf_counter()-g
       print("\r{:3.0f}%[{}->{}]{:.2f}s".format(d,b,c,e),end='')
       time.sleep(0.1)
   print("\n"+"执行结束".center(a//2,'-'))
   ```

3. # **三次方格式化**

   ## **描述**

   获得用户输入的一个数字，可能是整数或浮点数，a，计算a的三次方值，并打印输出。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   输出结果采用宽度20个字符、居中输出、多余字符采用减号(-)填充。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   如果结果超过20个字符，则以结果宽度为准。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   |        | 输入 | 输出                   |
   | ------ | ---- | ---------------------- |
   | 示例 1 | `10` | `--------1000--------` |

   ```python
   a=input()
   print("{:-^20}".format(pow(eval(a),3)))
   ```

4. # 星号三角形

   ## **描述**

   读入一个整数N，N是奇数，输出由星号字符组成的等边三角形，要求：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   第1行1个星号，第2行3个星号，第3行5个星号，依次类推，最后一行共N的星号。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   |        | 输入 | 输出      |
   | ------ | ---- | --------- |
   | 示例 1 | `3`  | ` *  ***‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬` |

    ```python
   a=eval(input())
   b=1
   while(a!=b):
       print("{0:^{1}}".format('*'*b,a))#这行用了控制输出宽度为输入的a的操作
       b+=2
   print("{}".format(a*'*'))
   
   
   
   n = eval(input())
   for i in range(1,n+1,2):
       print("{0:^{1}}".format('*'*i, n))
   关键是对.format()中槽机制的理解，槽中可以嵌套槽，用来表示宽度、填充等含义。
    ```

5. # 恺撒密码

   ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## 描述

   恺撒密码是古罗马恺撒大帝用来对军事情报进行加解密的算法，它采用了替换方法对信息中的每一个英文字符循环替换为字母表序列中该字符后面的第三个字符，即，字母表的对应关系如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   对于原文字符P，其密文字符C满足如下条件：C=(P+3) mod 26‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   上述是凯撒密码的加密方法，解密方法反之，即：P=(C-3) mod 26‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   假设用户可能使用的输入包含大小写字母a~zA~Z、空格和特殊符号，请编写一个程序，对输入字符串进行恺撒密码加密，直接输出结果，其中空格不用进行加密处理。使用input()获得输入。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ------

   ## 输入

   示例1: python is good‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ------

   ## 输出

   示例1: sbwkrq lv jrrg

   ```python
   #s=input()
   #for i in range(len(s)):
   #    if ('a'<=s[i] and s[i]<='z') or ('A'<=s[i] and s[i]<='Z'):
   #        if('a'<=s[i] and s[i]<='z'):
   #            s[i]=chr((((ord(s[i])-ord('a'))+3)%26)+ord('a'))
   #        else:
   #            s[i]=chr((((ord(s[i])-ord('A'))+3)%26)+ord('A'))
   #print(s)
   #wrong
   
   #s=input()
   #for i in range(26):
   #    s=s.replace(chr(ord('a')+i),chr(((i+3)%26)+ord('a')))
   #    s=s.replace(chr(ord('A')+i),chr(((i+3)%26)+ord('A')))
   #print(s)
   #wrong
   
   s=input()
   t=""
   for i in range(len(s)):
       if ('a'<=s[i] and s[i]<='z') or ('A'<=s[i] and s[i]<='Z'):
           if('a'<=s[i] and s[i]<='z'):
               t+=chr((((ord(s[i])-ord('a'))+3)%26)+ord('a'))
           else:
               t+=chr((((ord(s[i])-ord('A'))+3)%26)+ord('A'))
       else:
           t+=s[i]
   print(t)
   
   
   s = input()
   t = ""
   for c in s:
       if 'a' <= c <= 'z': 
           t += chr( ord('a') + ((ord(c)-ord('a')) + 3 )%26 )
       elif 'A' <= c <= 'Z':
           t += chr( ord('A') + ((ord(c)-ord('A')) + 3 )%26 )
       else:
           t += c
   print(t)
   #恺撒密码加密算法由很多种编写方法，这是一种很直接的方法。
   ```

### 测验

#### 单项选择题

1. pow(x, 0.5)能够计算x的平方根，计算负数的平方根将产生：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 程序崩溃

   B. 无输出

   C. ValueError错误

   D. 复数

   D

   ```python
   >>> pow(-1, 0.5)
   (6.123233995736766e-17+1j)
   ```

2. 以下关于字符串.strip()方法功能说明正确的是：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 去掉字符串两侧指定字符

   B. 连接两个字符串序列

   C. 按照指定字符分割字符串为数组

   D. 替换字符串中特定字符

   A

   "去掉字符串两侧指定字符"对应功能是.strip()

   "按照指定字符分割字符串为数组"对应功能是.split()

   "替换字符串中特定字符"对应功能是.replace()

   "连接两个字符串序列"对应功能是+操作符

3. 字符串是一个连续的字符序列，哪个选项可以实现打印字符信息的换行？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 使用空格

   B. 使用“\换行”

   C. 使用转义符\\\

   D. 使用\n

   D

   换行符\n，与C语言中一致。

4. val=pow(2,1000)，请用一行代码返回val结果的长度值。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 其他答案均不正确

   B. len(val)

   C. len(str(val))

   D. len(pow(2,1000))

   C

   len(str(val))首先通过str(val)将数字类型val变成字符串，再通过len()获得字符串长度，即val的数字个数。

5. 下面关于time库引用不正确的是？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. from time import *

   B. from time import strftime

   C. from * import time

   D. import time

   C

   from * import time 应该是： from time import *

6. 哪个选项不是Python语言的整数类型？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 0B1010

   B. 0E99

   C. 0x9a

   D. 88

   B

   十进制：一般表示

   二进制：0b 或 0B 开头

   八进制：0o 或 0O 开头

   十六进制：0x 或 0X 开头

   没有0E开头

7. 关于整数类型的4种进制表示，哪个选项的描述是正确的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 二进制、四进制、八进制、十进制

   B. 二进制、四进制、十进制、十六进制

   C. 二进制、八进制、十进制、十六进制

   D. 二进制、四进制、八进制、十六进制

   C

   Python不支持四进制整数

8. 哪个选项是Python语言%运算符的含义？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. x与y的整数商

   B. x与y之商

   C. x的y次幂

   D. x与y之商的余数

   D

   %是取余数，与C语言相同。

9. 哪个选项是下面代码的执行结果？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ```python
   name="Python语言程序设计课程"
   print(name[0],name[2:-2],name[-1])
   ```


   ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬A. P thon语言程序设计 程

   B. P thon语言程序设计课 课

   C. P thon语言程序设计课 程

   D. P thon语言程序设计 课

   A

   s[N:M]表示对字符串s的切片操作，从N到M，但不包含M

10. 哪个选项是下面代码的执行结果？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ```python
    s='PYTHON'
    print("{0:3}".format(s))
    ```

    A.       PYTHON

    B. PYTHON

    C. PYTH

    D. PYT

    B

    {0:3}表示输出的宽度是3，但如果字符串超过长度3，则以字符串长度显示。

#### 程序设计题

1. # **平方根格式化**

   ## **描述**

   获得用户输入的一个整数a，计算a的平方根，保留小数点后3位，并打印输出。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   输出结果采用宽度30个字符、右对齐输出、多余字符采用加号(+)填充。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   如果结果超过30个字符，则以结果宽度为准。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   |        | 输入 | 输出                             |
   | ------ | ---- | -------------------------------- |
   | 示例 1 | `10` | `+++++++++++++++++++++++++3.162` |

   ```python
   a=eval(input())
   a=pow(a,0.5)
   print("{:+>30.3f}".format(a))
   
   
   
   【参考代码】
   
   a = eval(input())
   print("{:+>30.3f}".format(pow(a, 0.5)))
   这是一个简单题，重点在于理解格式化输出的方法。
   
   注意：如果平凡根后产生一个复数，由于复数的实部和虚部都是浮点数，.3f可以将实部和虚部分别取三位小数。
   ```

2. # **字符串分段组合**

   ## **描述**

   获得输入的一个字符串s，以字符减号(-)分割s，将其中首尾两段用加号(+)组合后输出。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   |        | 输入                                 | 输出           |
   | ------ | ------------------------------------ | -------------- |
   | 示例 1 | `Alice-Bob-Charis-David-Eric-Flurry` | `Alice+Flurry` |

   ```python
   s=input()
   a=0
   while(s[a]!='-'):a+=1
   b=len(s)-1
   while(s[b]!='-'):b-=1
   print("{}+{}".format(s[:a],s[b+1:]))
   
   
   
   参考代码如下：
   
   s = input()
   ls = s.split("-")
   print("{}+{}".format(ls[0], ls[-1]))
   
   s.split(k)以k为标记分割s，产生一个列表。通过该题目，掌握split()方法的使用，注意：k可以是单字符，也可以是字符串。
   ```

   
