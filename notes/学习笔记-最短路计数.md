# 【学习笔记】最短路计数

#### 前言

在补一些之前写了没A的题目的时候遇到了逛公园这题

然后[这位大佬的题解](<https://kelin.blog.luogu.org/solution-p3953>)又让我再次看到了我之前写过的

[P1144最短路计数](https://www.luogu.org/problemnew/show/P1144)

和没写过的

[P1608路径统计](https://www.luogu.org/problemnew/show/P1608)

我本以为[P1608路径统计](https://www.luogu.org/problemnew/show/P1608)是一道和最短路计数一样的水题，但是在遇到一些问题，进行一些思考之后，我发现我对最短路算法spfa和dijkstra的应用更加熟悉了一点点

我个人认为这篇文章对像我一样以前只会简单码spfa和dijkstra的同学将会有所裨益QAQ

## 我的思考过程

本文将向您展现我对这两题的一个思考过程，如果您对这两题的写法不是很清楚，可以参考我的思考过程

如果有哪些部分有误，还请与[我](<https://www.luogu.org/space/show?uid=59700>)私信联系QAQ~~但是我马上就退役了，联系肯定是假的qwq~~

[P1144最短路计数](https://www.luogu.org/problemnew/show/P1144)这题我的写法是spfa

```cpp
	for(int i=1;i<=n;i++) dist[i]=2000001;
    dist[1]=0;v[1]=1;ans[1]=1;
    queue<int> q;
    q.push(1);
    while(!q.empty())
    {
        int x=q.front();q.pop();
        for(int i=h[x];i;i=e[i].nxt)
        {
            int y=e[i].v;
            if(dist[y]>dist[x]+1)
            {
                dist[y]=dist[x]+1;
                ans[y]=ans[x];
                if(!v[y])
                {
                    v[y]=1;
                    q.push(y);
                }
            }
            else if(dist[y]==dist[x]+1)
            {
                ans[y]=(ans[y]+ans[x])%100003;
                if(!v[y])
                {
                    v[y]=1;
                    q.push(y);
                }
            }
        }
        v[x]=0;
    }
```

也就是在处理spfa的时候当能够松弛（dist[y]>dist[x]+1）时，直接将ans[y]覆盖为ans[x]，而相等时将到x最短路条数累加到y

由于spfa是广搜，这题给的无权图相当于边权为1，注意，此时如果把搜索的顺序编为树，那么**树的深度即为距离**

比如

![](/pictures/note-最短路计数1.png)

对于上面这幅图跑上面的算法搜索顺序（或者说更新顺序）是

![](/pictures/note-最短路计数2.png)

所以在搜索4连到的点的时候，4的ans已经固定不会再改了（思考一下为什么）

当您搜完4所连点（我习惯叫做“扩展4”）之后，什么情况会再搜到4？

就是队列中在4后面的某一个点x有连向4的边，但是这个点x的深度/距离一定会大于等于4的深度/距离（spfa是广搜啊QAQ），因此x在搜到4时不会更新4的ans，更没有能力将4再次加入队列

同时您也会发现，当dist[y]==dist[x]+1时，我们可以不考虑再把y加入队列的事（删掉也能过）

因为此时肯定是队列中在x前的，与x深度相同的某一点x'也连到了y，将dist[y]=dist[x']+1，这时候已经把y加入了队列里面，并且一定是在把这些深度为dist[y]-1的点都搜完了，把其中能连到y的点的答案累加到y之后才会扩展y

