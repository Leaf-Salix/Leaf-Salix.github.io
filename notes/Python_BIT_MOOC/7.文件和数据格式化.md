## 7.文件和数据格式化

### 7.1 文件的使用

#### 文件的类型

- 文件的理解

  - 文件是数据的抽象和集合
    - 文件是储存在辅助储存器上的数据序列
    - 文件是数据存储的一种形式
    - 文件展现形态：文本文件和二进制文件
  - 文本文件&二进制文件
    - 文本文件和二进制文件只是文件的展示方式
    - 本质上，所有文件都是二进制形式存储
    - 形式上，所有文件采用两种方式展示
  - 文件是数据的抽象和集合
    - 由单一特定编码组成的文件，如UTF-8编码
    - 由于存在编码，文本文件也被看成是存储着的长字符串
    - 适用于例如：.txt文件、.py文件

- 二进制文件

  - 文件是数据的抽象和集合
    - 直接由比特0和1组成，没有统一字符编码
    - 一般存在二进制0和1的组织结构，即文件格式
    - 适用于例如：.png文件、.avi文件

- 文本文件&二进制文件

  - "中国是个伟大的国家!"

    - 文本形式（如UTF-8）

      中国是个伟大的国家!

    - 二进制形式（对应的存储形态的二进制形式）

      b'\xd6\xd0\xb9\xfa\xca\xc7\xb8\xf6\xce\xb0\xb4\xf3\xb5\xc4\xb9\xfa\xbc\xd2\xa3\xa1'

  - f.txt文件保存:"中国是个伟大的国家!"

    ```python
    #文本形式打开文件
    tf=open("f.txt","rt")
    print(tf.readline())#读出一行并打印输出
    tf.close()
    ---
    #二进制形式打开文件
    bf=open("f.txt","rb")
    print(bf.readline())
    bf.close()
    ```

#### 文件的打开和关闭

- 文件处理的步骤：打开-操作-关闭

  - 打开：“文件的存储状态”由a=open(,)到“文件的占用状态”

  - 关闭：“文件的占用状态”由a.close()到“文件的存储状态”

  - 操作：

    - 读文件

      a.read(size)

      a.readline(size)

      a.readlines(hint)

    - 写文件

      a.write(s)

      a.writelines(lines)

      a.seek(offset)

- 文件的打开

  <变量名>=open(<文件名>,<打开模式>)

  - 文件名：文件路径和名称（源文件同目录可省去路径）

  - 打开模式：文本or二进制，读or写

  - 变量名：文件句柄

  - 例子：

    - 需要打开的文件是：D:\PYE\f.txt

      - 绝对路径

        由于在windows下文件路径使用的是\反斜杠

        而\在python字符串中被解析为转义符

        所以一般用/斜杠替代\反斜杠

        即"D:/PYE/f.txt"

        当然也可以用\\\替代\

        即"D:\\\\PYE\\\\f.txt"

      - 相对路径（相对于当前.py文件所在的路径）

        如当前.py文件存在D盘根目录

        "./PYE/f.txt"

        如当前.py文件和要打开的f.txt在同一目录

        "f.txt"

- 打开模式

  - 'r'

    只读模式，默认值，如果文件不存在，返回FileNotFoundError

  - 'w'

    覆盖写模式，文件不存在则创建，存在则完全覆盖

  - 'x'

    创建写模式，文件不存在则创建，存在则返回FileExistsError

  - 'a'

    追加写模式，文件不存在则创建，存在则在文件最后追加内容

  - 't'

    文本文件模式，默认值

  - 'b'

    二进制文件模式

  - '+'

    与r/w/x/a一同使用，在原功能基础上增加同时读写功能

  - 例子：

    - f=open("f.txt")

      默认值：文本形式、只读模式

    - f=open("f.txt","rt")

      同默认值：文本形式、只读模式

    - f=open("f.txt","w")

      文本形式、覆盖写模式

    - f=open("f.txt","a+")

      文本形式、追加写模式+可读文件信息

    - f=open("f.txt","x")

      文本形式、创建写模式

    - f=open("f.txt","b")

      二进制形式、只读模式

    - f=open("f.txt","wb")

      二进制形式、覆盖写模式

- 文件的关闭

  <变量名>.close()

  如果不在程序中写这句话，文件会在程序运行过程中保持打开状态，而只要程序正常退出，文件也会被自动关闭

#### 文件内容的读取

- 文件内容的读取

  - \<f>.read(size=-1)

    读入全部内容，如果给出参数，读入前size长度

    \>\>\>s=f.read(2)

    中国

  - \<f>.readline(size=-1)

    读入一行内容，如果给出参数，读入该行前size长度

    \>\>\>s=f.readline()

    中国是个伟大的国家!

  - \<f>.readlines(hint=-1)

    读入文件所有行，以每行为元素形成列表

    如果给出参数，读入前hint行

    \>\>\>s=f.readlines()

    ['中国是个伟大的国家!']

- 文件的全文本操作

  - 遍历全文本：方法一

    ```python
    fname=input("请输入要打开的文件名称:")
    fo=open(fname,"r")
    txt=fo.read()
    #对全文txt进行处理
    fo.close()
    #一次读入，统一处理
    ```

    弊端：如果文件体量很大，一次读入代价很大，需要分批次读入、处理

  - 遍历全文本：方法二

    ```python
    fname=input("请输入要打开的文件名称:")
    fo=open(fname,"r")
    txt=fo.read(2)
    while txt!="":
        #对txt进行处理
        txt=fo.read(2)
    fo.close()
    #按数量读入，逐步处理
    ```

- 文件的逐行操作

  - 逐行遍历文件：方法一

    ```python
    fname=input("请输入要打开的文件名称:")
    fo=open(fname,"r")
    for line in fo.readlines():#遍历fo.readlines()这个列表
        print(line)
    fo.close()
    #一次读入，分行处理
    ```

  - 逐行遍历文件：方法二

    ```python
    fname=input("请输入要打开的文件名称:")
    fo=open(fname,"r")
    for line in fo:
        print(line)
    fo.close()
    #分行读入，逐行处理（针对极大文件）
    ```

#### 数据的文件写入

- 数据的文件写入

  - \<f>.write(s)

    向文件写入一个字符串或字节流

    \>\>\>f.write("中国是个伟大的国家!")

  - \<f>.writelines(lines)

    将一个元素全为字符串的列表写入文件

    \>\>\>ls=["中国","法国","美国"]

    \>\>\>f.writelines(ls)

    中国法国美国

    虽然叫writelines，写入的方式并不是分行写入，而是直接拼接列表中的字符串写入，没有换行、空格

  - \<f>.seek(offset)#辅助写入的函数

    改变当前文件操作指针的位置，offset含义如下：

    0-文件开头    1-当前位置    2-文件结尾

    \>\>\>f.seek(0)#回到文件开头

  - 例子：

    ```python
    fo=open("output.txt","w+")
    ls=["中国","法国","美国"]
    fo.writelines(ls)
    for line in fo:
        print(line)
    fo.close()
    #写入一个字符串列表
    ```

    我们以为在print后会输出中国法国美国，但是实际上却没有任何输出

    这是因为输入后指针在文件末尾，而输出则是从当前位置向文件结尾处取出每一行并打印出来

    可以用seek(0)，将指针回到文件开头

    ```python
    fo=open("output.txt","w+")
    ls=["中国","法国","美国"]
    fo.writelines(ls)
    fo.seek(0)
    for line in fo:
        print(line)
    fo.close()
    ```

### 7.2 实例11：自动轨迹绘制

#### “自动轨迹绘制”问题分析

- 自动轨迹绘制

  - 需求：根据脚本来绘制图形

  - 不是写代码而是写数据绘制轨迹

  - 使用数据脚本是自动化最重要的第一步

  - 给出文件，例如文件中有以下内容

    300,0,144,1,0,0

    300,0,144,0,1,0

    300,0,144,0,0,1

    300,0,144,1,1,0

    300,0,108,0,1,1

    184,0,72,1,0,1

#### “自动轨迹绘制”实例讲解

- 基本思路

  - 步骤1：定义数据文件格式（接口）
  - 步骤2：编写程序，根据文件接口解析参数绘制图形
  - 步骤3：编制数据文件

- 数据接口定义

  - 非常具有个性色彩（自己决定）

    如上面的数据形式中

    第一个数据表示行进距离，第二个0为左转1为右转，第三个是转向角度，最后三个是RGB三个通道颜色

```python
#AutoTraceDraw.py
import turtle as t
t.title('自动轨迹绘制')
t.setup(800,600,0,0)
t.pencolor("red")
t.pensize(5)
#数据读取
datals=[]
f=open("data.txt")
for line in f:
    line=line.replace("\n","")
    datals.append(list(map(eval,line.split(","))))
    #map可以将第一个参数的功能作用于第二个参数（列表，组合数据类型）的每个元素
    #即用line.split生成一个包含多个“内容为数字的字符串”的列表
    #用map(eval,列表)将列表中的每个数字字符串变成数字
    #将整个列表当作一个元素放入列表datals末尾
f.close()
#自动绘制
for i in range(len(datals)):
    t.pencolor(datals[i][3],datals[i][4],datals[i][5])
    t.fd(datals[i][0])
    if datals[i][1]:
        t.right(datals[i][2])
    else:
        t.left(datals[i][2])
---
在同目录下创建data.txt，输入
300,0,144,1,0,0
300,0,144,0,1,0
300,0,144,0,0,1
300,0,144,1,1,0
300,0,108,0,1,1
184,0,72,1,0,1
184,0,72,0,0,0
184,0,72,0,0,0
184,0,72,0,0,0
184,1,72,1,0,1
184,1,72,0,0,0
184,1,72,0,0,0
184,1,72,0,0,0
184,1,72,0,0,0
184,1,720,0,0,0
```

#### “自动轨迹绘制”举一反三

- 理解方法思维
  - 自动化思维：数据和功能分离，数据驱动的自动进行
  - 接口化设计：格式化设计接口，清晰明了
  - 二维数据应用：应用维度组织数据，二维数据最常用
- 应用问题的扩展
  - 扩展接口设计，增加更多控制接口
  - 扩展功能设计，增加弧形等更多功能
  - 扩展应用需求，发展自动轨迹绘制到动画绘制

### 7.3 一维数据的格式化和处理

#### 数据组织的维度

- 从一个数据到一组数据

  一个数据表达一个含义->一组数据表达一个或多个含义

- 维度：一组数据的组织形式

  线性？二维？

- 一维数据

  - 由对等关系的有序或无序数据构成，采用线性方式组织
    - 对应列表、数组、集合等概念

- 二维数据

  - 由多个一维数据构成，是一维数据的组合形式

    如中国大学排行榜

    - 表格是典型的二维数据
    - 其中，表头可以作为或不作为二维数据的一部分

- 多维数据

  - 由一维或二维数据在新维度上扩展形成

    如中国大学排行榜在时间维度上有2016、2017、2018...

- 高维数据

  - 仅利用最基本的二元关系展示数据间的复杂结构

    - 键值对

      如{'a':{'a':1,'b':2}}

- 数据的操作周期

  - 存储<->表示<->操作
    - 数据存储：我们关心存储格式
    - 数据表示：我们关心数据类型
    - 数据操作：我们关心操作方式

#### 一维数据的表示

- 一维数据的表示
  - 如果数据间有序：使用列表类型
    - 列表类型可以表达一维有序数据
    - for循环可以遍历数据，进而对每个数据进行处理
  - 如果数据间无序：使用集合类型
    - 集合类型可以表达一维无序数据
    - for循环可以遍历数据，进而对每个数据进行处理

#### 一维数据的存储

- 一维数据的存储

  - 存储方式一：空格分隔

    中国 美国 日本 德国 法国 英国 意大利

    - 使用一个或多个空格分隔进行存储，不换行
    - 缺点：要求数据中不能存在空格

  - 存储方式二：逗号分隔

    中国,美国,日本,德国,法国,英国,意大利

    - 使用英文半角逗号分隔数据进行存储，不换行
    - 缺点：要求数据中不能有英文逗号

  - 存储方式三：其他方式

    中国\$美国\$日本\$德国\$法国\$英国\$意大利

    - 使用其他符号或符号组合分隔，建议采用特殊符号
    - 缺点：需要根据数据特定定义，通用性较差

#### 一维数据的处理

- 数据的处理

  - 存储<->表示
    - 将存储的数据读入程序
    - 将程序表示的数据写入文件

- 一维数据的读入处理

  - 从空格分隔的文件中读入数据

    中国 美国 日本 德国 法国 英国 意大利

    ```python
    txt=open(fname).read()
    ls=txt.split()
    f.close()
    ```

  - 从特殊符号分隔的文件中读入数据

    中国\$美国\$日本\$德国\$法国\$英国\$意大利

    ```python
    txt=open(fname).read()
    ls=txt.split("$")
    f.close()
    ```

- 一维数据的写入处理

  - 采用空格分隔方式写入文件

    ```python
    ls=['中国','美国','日本']
    f=open(fname,'w')
    f.write(' '.join(ls))
    f.close()
    ```

  - 采用特殊分隔方式将数据写入文件

    ```python
    ls=['中国','美国','日本']
    f=open(fname,'w')
    f.write('$'.join(ls))
    f.close()
    ```

### 7.4 二维数据的格式化和处理

#### 二维数据的表示

- 二维数据的表示

  - 使用列表类型

    - 列表类型可以表达二维数据

    - 使用二维列表

      [[3.1398,3.1349,3.1376],[3.1413,3.1404,3.1401]]

    - 使用两层for循环遍历每个元素

    - 外层列表中每个元素可以对应一行，也可以对应一列

- 一二维数据的Python表示

  - 数据维度是数据的组织形式
    - 一维数据：列表和集合类型
    - 二维数据：列表类型

#### CSV格式于二维数据的存储

- CSV数据存储格式

  - CSV:Comma-Separated Values

    - 国际通用的一二维数据存储格式，一般.csv扩展名

    - 每行一个一维数据，采用逗号分隔，无空行

    - Excel和一般编辑软件都可以读入或另存为csv文件

    - 实例：

      | 城市 | 环比  | 同比  | 定基  |
      | :--: | :---: | :---: | :---: |
      | 北京 | 101.5 | 120.7 | 121.4 |
      | 上海 | 101.2 | 127.3 | 127.8 |
      | 广州 | 101.3 | 119.4 | 120.0 |
      | 深圳 | 102.0 | 140.0 | 145.5 |
      | 沈阳 | 100.0 | 101.4 | 101.6 |

      转换为CSV格式后是：

      城市,环比,同比,定基
      北京,101.5,120.7,121.4
      上海,101.2,127.3,127.8
      广州,101.3,119.4,120.0
      深圳,102.0,140.0,145.5
      沈阳,100.0,101.4,101.6

    - 如果某个元素缺失，逗号仍要保留

    - 二维数据的表头可以作为数据存储，也可以另行存储

    - 逗号为英文半角符号，逗号与数据之间无额外空格

    - 对于数据中出现的逗号，有两边加“”和\转义符的方法解决，而CSV是一种较成熟的体系，能处理这样的问题，这里我们暂时不考虑这个问题

- 二维数据的存储

  - 按行存？按列存？
    - 按行存或者按列存都可以，具体由程序决定
    - 一般索引习惯：ls\[row]\[column]，先行后列
    - 根据一般习惯，外层列表每个元素是一行，按行存

#### 二维数据的处理

- 二维数据的读入处理

  - 从CSV格式的文件中读入数据

    ```python
    fo=open(fname)
    ls=[]
    for line in fo:
        line=line.replace("\n","")
        ls.append(line.split(","))
    fo.close()
    ```

  - 将数据写入CSV格式的文件

    ```python
    ls=[[],[],[]]#二维列表
    f=open(fname,'w')
    for item in ls:
        f.write(','.join(item)+'\n')
    f.close()
    ```

- 二维数据的逐一处理

  - 采用二层循环

    ```python
    ls=[[1,2],[3,4],[5,6]]#二维列表
    for row in ls:
        for column in row:
            print(column)
    ```

### 7.5 模块6：wordcloud库的使用

#### wordcloud库基本介绍

- wordcloud是优秀的词云展示第三方库

  - 词云以词语为基本单位，更加直观和艺术的展示文本

- wordcloud库安装

  cmd命令行：pip install wordcloud

#### wordcloud库使用说明

- wordcloud库基本使用

  - wordcloud库把词云当作一个WordCloud对象
    - wordcloud.WordCloud()代表一个文本对应的词云
    - 可以根据文本中词语出现的频率等参数绘制词云
    - 绘制词云的形状、尺寸和颜色都可以设定

- wordcloud库常规方法

  - w=wordcloud.WordCloud()

    - 以WordCloud对象为基础

    - 配置参数、加载文本、输出文件

    - w.generate(txt)

      向WordCloud对象w中加载文本txt

      \>\>\>w.generate("Python and WordCloud")

    - w.to_file(filename)

      将词云输出为图像文件，.png/.jpg/...格式

      \>\>\>w.to_file("outfile.png")

  - 步骤1：配置对象参数

  - 步骤2：加载词云文本

  - 步骤3：输出词云文件

  - 实例：

    ```python
    import wordcloud
    c=wordcloud.WordCloud()
    c.generate("wordcloud by Python")
    c.to_file("pywordcloud.png")
    ```

    其中wordcloud库做了四件事

    - 分隔：以空格分隔单词
    - 统计：单词出现次数并过滤
    - 字体：根据统计配置字号
    - 布局：颜色环境尺寸

- 配置对象参数

  - w=wordcloud.WordCloud(<参数>)

    - width

      指定词云对象生成图片的宽度，默认400像素

      \>\>\>w=wordcloud.WordCloud(width=600)

    - height

      指定词云对象生成图片的高度，默认200像素

      \>\>\>w=wordcloud.WordCloud(height=400)

    - min_font_size

      指定词云中字体的最小字号，默认4号

      \>\>\>w=wordcloud.WordCloud(min_font_size=10)

    - max_font_size

      指定词云中字体的最大字号，根据高度自动调节

      \>\>\>w=wordcloud.WordCloud(max_font_size=20)

    - font_step

      指定词云中字体字号的步进间隔，默认为1

      \>\>\>w=wordcloud.WordCloud(font_step=2)

    - font_path

      指定字体文件的路径，默认None

      \>\>\>w=wordcloud.WordCloud(font_path="msyh.ttc")#这里指中文字体用微软雅黑

    - max_words

      指定词云显示的最大单词数量，默认200

      \>\>\>w=wordcloud.WordCloud(max_words=20)

    - stop_words#应该是stopwords

      指定词云的排除词列表，即不显示的单词列表

      \>\>\>w=wordcloud.WordCloud(stop_words={"Python"})#一般用集合类型

    - mask

      指定词云形状，默认为长方形，需要引用imread()函数

      \>\>\>from scipy.misc import imread

      \>\>\>mk=imread("pic.png")

      \>\>\>w=wordcloud.WordCloud(mask=mk)

    - background_color

      指定词云图片的背景颜色，默认为黑色

      \>\>\>w=wordcloud.WordCloud(background_color="white")

- wordcloud应用实例

  ```python
  import wordcloud
  txt="life is short, you need python"
  w=wordcloud.WordCloud(background_color="white")
  w.generate(txt)
  w.to_file("pywcloud.png")
  ---
  import jieba
  import wordcloud
  txt="程序设计语言是计算机能够理解和\
  识别用户操作意图的一种交互体系，它按照\
  特定规则组织计算机指令，使计算机能够自\
  动进行各种运算处理"
  w=wordcloud.WordCloud(width=1000,height=700,font_path="msyh.ttc")
  w.generate(" ".join(jieba.lcut(txt)))
  w.to_file("pywcloud.png")
  ```

### 7.6 实例12：政府工作报告词云

#### “政府工作报告词云”问题分析

- 问题分析

  - 直观理解政策文件

    - 需求：对于政府工作报告等政策文件，如何直观理解

    - 体会直观的价值：生成词云&优化词云

      政府报告等文件->有效展示的词云

    - [《决胜全面建成小康社会 夺取新时代中国特色社会主义伟大胜利》](https://python123.io/resources/pye/%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89.txt)

    - [《中共中央 国务院关于实施乡村振兴战略的意见》](https://python123.io/resources/pye/%E5%85%B3%E4%BA%8E%E5%AE%9E%E6%96%BD%E4%B9%A1%E6%9D%91%E6%8C%AF%E5%85%B4%E6%88%98%E7%95%A5%E7%9A%84%E6%84%8F%E8%A7%81.txt)

#### “政府工作报告词云”实例解析

- 政府工作报告词云

  - 基本思路
    - 步骤1：读取文件、分词整理
    - 步骤2：设置并输出词云
    - 步骤3：观察结果，优化迭代

- ```python
  #GovRptWordCloudv1.py
  import jieba,wordcloud
  f=open("新时代中国特色社会主义.txt","r",encoding="utf-8")
  t=f.read()
  f.close()
  ls=jieba.lcut(t)
  txt=" ".join(ls)
  w=wordcloud.WordCloud(font_path="msyh.ttc",\
                        width=1000,height=700,background_color="white",\
                        max_words=15)
  w.generate(txt)
  
  w.to_file("grwordcloud.png")
  ---
  #GovRptWordCloudv1.py
  import jieba,wordcloud
  f=open("关于实施乡村振兴战略的意见.txt","r",encoding="utf-8")
  t=f.read()
  f.close()
  ls=jieba.lcut(t)
  txt=" ".join(ls)
  w=wordcloud.WordCloud(font_path="msyh.ttc",\
                        width=1000,height=700,background_color="white",\
                        max_words=15)
  w.generate(txt)
  
  w.to_file("grwordcloud.png")
  ```

- 更有型的词云

  需要在根目录提供背景为白色的图案，如下面的fu.png文件

  并安装scipy库

  ```python
  #GovRptWordCloudv2.py
  import jieba,wordcloud
  from scipy.misc import imread
  mask=imread("fu.png")
  f=open("新时代中国特色社会主义.txt","r",encoding="utf-8")
  t=f.read()
  f.close()
  ls=jieba.lcut(t)
  txt=" ".join(ls)
  w=wordcloud.WordCloud(font_path="msyh.ttc",mask=mask,\
                        width=1000,height=700,background_color="white")
  w.generate(txt)
  
  w.to_file("grwordcloud.png")
  ---
  注意，from scipy.misc import imread,imwrite等方法已被弃用，Python已经将imread方法封装在了imageio模块中，需要安装imageio库，使用以下方法
  ---
  #GovRptWordCloudv2.py
  import jieba,wordcloud
  import imageio
  msk=imageio.imread("fu.jpg")
  f=open("新时代中国特色社会主义.txt","r",encoding="utf-8")
  t=f.read()
  f.close()
  ls=jieba.lcut(t)
  txt=" ".join(ls)
  w=wordcloud.WordCloud(font_path="msyh.ttc",mask=msk,\
                        width=1000,height=700,background_color="white")
  w.generate(txt)
  
  w.to_file("grwordcloud.png")
  ```

#### “政府工作报告词云”举一反三

- 举一反三
  - 扩展能力
    - 了解wordcloud更多参数，扩展词云能力
    - 特色词云：设计一款属于自己的特色词云风格
    - 更多文件：用更多文件练习词云生成

### 练习

1. # **文件行数**

   ## **描述**

   打印输出附件文件的有效行数，注意：空行不计算为有效行数。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   这是仅给出输出格式样例，不是结果。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   |        | 输入 | 输出      |
   | ------ | ---- | --------- |
   | 示例 1 | ``   | `共100行` |

    ```python
   f=open("latex.log","r")
   cnt=0
   for line in f.readlines():
       if line=='\n':
           continue
       else:
           cnt+=1
   print("共{}行".format(cnt))
   ---
   f = open("latex.log")
   s = 0
   for line in f:
       line = line.strip('\n')
       if len(line) == 0:
           continue
       s += 1
   print("共{}行".format(s))
   需要注意：for line in f方式获得的每行内容（在变量line中）包含换行符，所以，要通过strip()函数去掉换行符后再进行统计。这里，空行指没有字符的行。
    ```

2. # **文件字符分布**

   ## **描述**

   统计附件文件的小写字母a-z的字符分布，即出现a-z字符的数量，并输出结果。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   同时请输出文件一共包含的字符数量。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   注意输出格式，各元素之间用英文逗号（,）分隔。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   答案可能包含a-z共26个字符的分布，如果某个字符没有出现，则不显示，输出顺序a-z顺序。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   仅格式示例，非最终答案。
   ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   |        | 输入 | 输出                                 |
   | ------ | ---- | ------------------------------------ |
   | 示例 1 | ``   | `共999字符,a:11,b:22,c:33,d:44,e:55` |

    ```python
   f=open("latex.log")
   txt=f.read()
   dic={}
   for i in txt:
       if 'a'<=i<='z':
           dic[i]=dic.get(i,0)+1
   print("共{}字符".format(len(txt)),end="")
   for i in range(ord('a'),ord('z')+1):
       if dic.get(chr(i),0)!=0:
           print(",{}:{}".format(chr(i),dic[chr(i)]),end="")
   ---
   f = open("latex.log")
   cc = 0
   d = {}
   for i in range(26):
       d[chr(ord('a')+i)] = 0
   for line in f:
       for c in line:
           d[c] = d.get(c, 0) + 1
           cc += 1
   print("共{}字符".format(cc), end="")
   for i in range(26):
       if d[chr(ord('a')+i)] != 0:
           print(",{}:{}".format(chr(ord('a')+i), d[chr(ord('a')+i)]), end="")
   使用 ord('a')+i 配合 range()函数 可以遍历一个连续的字符表。
    ```

3. # **文件独特行数**

   ## **描述**

   统计附件文件中与其他任何其他行都不同的行的数量，即独特行的数量。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   此处仅示例输出格式。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   |        | 输入 | 输出         |
   | ------ | ---- | ------------ |
   | 示例 1 | ``   | `共99独特行` |

    ```python
   ans=0
   f=open("latex.log")
   txt=f.readlines()
   dic={}
   for lines in txt:
       if dic.get(lines,0)==0:
           dic[lines]=1
           ans+=1
       elif dic[lines]==1:
           dic[lines]=2
           ans-=1
   print("共{}独特行".format(ans))
   ---
   f = open("latex.log")
   ls = f.readlines()
   s = set(ls)
   for i in s:
       ls.remove(i)
   t = set(ls)
   print("共{}独特行".format(len(s)-len(t)))
   记住：如果需要"去重"功能，请使用集合类型。
   
   ls.remove()可以去掉某一个元素，如果该行是独特行，去掉该元素后将不在集合t中出现。
    ```

4. # **CSV格式列变换**

   ## **描述**

   附件是一个CSV文件，请将每行按照列逆序排列后输出，不改变各元素格式（如周围空格布局等）。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   这是一个格式示例，不是正确结果。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   |        | 输入                                 | 输出              |
   | ------ | ------------------------------------ | ----------------- |
   | 示例 1 | `（以下是文件内容） 1,2,3,4 a,b,c,d` | `4,3,2,1 d,c,b,a` |

    ```python
   f=open("data.csv")
   txt=f.readlines()
   ls=[]
   for line in txt:
       line=line.replace('\n',"")
       lt=line.split(',')
       lt.reverse()#lt=lt.reverse()
       ls.append(lt)
   for lt in ls:
       print(','.join(lt))
   ---
   f = open("data.csv")
   for line in f:
       line = line.strip("\n")
       ls = line.split(",")
       ls = ls[::-1]
       print(",".join(ls))
   f.close()
    ```

5. # **CSV格式数据清洗**

   ## **描述**

   附件是一个CSV文件，其中每个数据前后存在空格，请对其进行清洗，要求如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   （1）去掉每个数据前后空格，即数据之间仅用逗号(,)分割；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   （2）清洗后打印输出。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   这里是一个格式示例，不是正确结果。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   |        | 输入                                                  | 输出                            |
   | ------ | ----------------------------------------------------- | ------------------------------- |
   | 示例 1 | `（在文件中） 1, 2, 3, 4, 5 'a', 'b' , 'c' , 'd','e'` | `1,2,3,4,5 'a','b','c','d','e'` |

    ```python
   f=open("data.csv")
   for line in f:
       line=line.replace(" ","")
       print(line,end="")
   ---
   f = open("data.csv")
   s = f.read()
   s = s.replace(" ","")
   print(s)
   f.close()
   该CSV文件的每个数据中不包含空格，因此，可以通过替换空格方式来清洗。如果数据中包含空格，该方法则不适用。
    ```

### 测验

#### 单项选择题

1. 关于数据组织的维度，哪个选项的描述是错误的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 数据组织存在维度，字典类型用于表示一维和二维数据

   B. 高维数据由键值对类型的数据构成，采用对象方式组织

   C. 一维数据采用线性方式组织，对应于数学中的数组和集合等概念

   D. 二维数据采用表格方式组织，对应于数学中的矩阵

   A

   字典用于表示高维数据，一般不用来表示一二维数据。

2. 以下选项不是Python文件读操作的是：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. readtext()

   B. readlines()

   C. readline()

   D. read()

   A

   没有readtext()方法

3. 对于Python文件，以下描述正确的是：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 当文件以文本方式打开时，读取按照字节流方式

   B. 根据不同类型的文件，打开方式只能是文本或者二进制中的一种

   C. 当文件以二进制文件方式打开时，读取按照字符串方式

   D. 同一个文件可以既采用文本方式打开，也可以采用二进制方式打开

   D

   文件就在那里，二进制或文本方式打开只是对其不同的程序理解。

4. 关于CSV文件的描述，哪个选项的描述是错误的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. CSV文件的每一行是一维数据，可以使用Python中的列表类型表示

   B. 整个CSV文件是一个二维数据

   C. CSV文件格式是一种通用的、相对简单的文件格式，应用于程序之间转移表格数据

   D. CSV文件通过多种编码表示字符

   D

   一般来说，CSV文件都是文本文件，由相同编码字符组成。

5. 关于Python文件的‘+’打开模式，哪个选项的描述是正确的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 追加写模式

   B. 覆盖写模式

   C. 与r/w/a/x一同使用，在原功能基础上增加同时读写功能

   D. 只读模式

   C

   '+'打开模式的精髓在于它能够同时赋予文件的读写权限。

6. 给定列表ls = [1, 2, 3, "1", "2", "3"]，其元素包含2种数据类型，哪个选项是列表ls的数据组织维度？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 高维数据

   B. 二维数据

   C. 多维数据

   D. 一维数据

   D

   列表元素如果都是列表，其可能表示二维数据，例如：[[1,2], [3,4], [5,6]]。

   如果列表元素不都是的将列表，则它表示一维数据。

7. 关于文件关闭的close()方法，哪个选项的描述是正确的？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 文件处理后可以不用close()方法关闭文件，程序退出时会默认关闭

   B. 如果文件是只读方式打开，仅在这种情况下可以不用close()方法关闭文件

   C. 文件处理遵循严格的“打开-操作-关闭”模式

   D. 文件处理结束之后，一定要用close()方法关闭文件

   A

   打开文件后采用close()关闭文件是一个好习惯。如果不调用close()，当前Python程序完全运行退出时，该文件引用被释放，即程序退出时，相当于调用了close()。

8. 二维列表ls=[[1,2,3], [4,5,6],[7,8,9]]，哪个选项能获取其中元素5？‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. ls\[-2][-1]

   B. ls[4]

   C. ls\[-1][-1]

   D. ls\[1][1]

   D

   这是二维切片的使用方式。

9. 以下选项对文件描述错误的是：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   A. 文件是程序的集合和抽象

   B. 文件可以包含任何内容

   C. 文件是数据的集合和抽象

   D. 文件是存储在辅助存储器上的数据序列

   A

   函数或类是程序的集合和抽象，文件不是。

10. Python对文件操作采用的统一步骤是：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

    A. 打开—操作—关闭

    B. 操作—读取—写入

    C. 打开—读写—写入

    D. 打开—读取—写入—关闭

    A

    打开—操作—关闭 是一个统一步骤，其中，关闭可以省略。

#### 程序设计题

1. # **文本的平均列数**

   ## **描述**

   打印输出附件文件的平均列数，计算方法如下：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   （1）有效行指包含至少一个字符的行，不计算空行；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   （2）每行的列数为其有效字符数；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   （3）平均列数为有效行的列数平均值，采用四舍五入方式取整数进位。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   仅给出输出格式示例，非正确答案。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   |        | 输入 | 输出  |
   | ------ | ---- | ----- |
   | 示例 1 | `无` | `123` |

   ```python
   file=open("latex.log")
   txt=file.readlines()
   cnt1=0
   cnt2=0
   for line in txt:
       line=line.strip("\n")
       if len(line)==0:
           continue
       cnt1+=len(line)
       cnt2+=1
   if cnt2!=0:
       print(round(cnt1/cnt2))
   else:
       print(0)
   ---
   f = open("latex.log")
   s, c = 0, 0
   for line in f:
       line = line.strip("\n")
       if line == "":
           continue
       s += len(line)
       c += 1
   print(round(s/c))
   请注意：for line in f获取的line包含每行最后的换行符（\n），所以，去掉该换行符进行统计。
   ```

2. # **CSV格式清洗与转换 **

   ## **描述**

   附件是一个CSV格式文件，提取数据进行如下格式转换：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   （1）按行进行倒序排列；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   （2）每行数据倒序排列；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   （3）使用分号（;）代替逗号（,）分割数据，无空格；‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   按照上述要求转换后将数据输出。 ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   ## **输入输出示例**

   以下是一个格式示例，不是最终结果。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‭‬

   |        | 输入                                   | 输出                |
   | ------ | -------------------------------------- | ------------------- |
   | 示例 1 | `(以下内容在文件中) 1,2,3 4,5,6 7,8,9` | `9;8;7 6;5;4 3;2;1` |

   ```python
   file=open("data.csv")
   txt=file.readlines()
   ls=[]
   for line in txt:
       line=line.strip("\n")
       line=line.replace(" ","")##
       lt=line.split(",")
       lt=lt[::-1]
       ls.append(lt)
   ls.reverse()
   for lt in ls:
       print(";".join(lt))
   ---
   f = open("data.csv")
   ls = f.readlines()
   ls = ls[::-1]
   lt = []
   for item in ls:
       item = item.strip("\n")
       item = item.replace(" ", "")
       lt = item.split(",")
       lt = lt[::-1]
       print(";".join(lt))
   f.close()
   注意：使用strip()方法去掉每行最后的回车，使用replace()去掉每行元素两侧的空格。
   ```

